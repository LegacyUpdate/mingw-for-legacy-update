From 70bea73fbc6bf1c49251d5de73b9fa3614f184c2 Mon Sep 17 00:00:00 2001
From: Jakub Jelinek <jakub@redhat.com>
Date: Wed, 17 Dec 2025 09:13:58 +0100
Subject: [PATCH] i386: Obfuscate _mm_maskmove_si64 local variable [PR123155]

Even automatic variables in inline functions in installed headers need to be
obfuscated, as e.g.
is a valid program.  Most of the automatic variables are obfuscated, but one
has leaked in in the xmmintrin.h header.
gcc -S -O2 -O2 -Werror-implicit-function-declaration -march=novalake -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -msha -mxsavec -mxsaves -mclflushopt -mavx512vp2intersect -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mpconfig -mwbnoinvd -menqcmd -mserialize -mtsxldtrk -mamx-tile -mamx-int8 -mamx-bf16 -mkl -mwidekl -mavxvnni -mavxifma -mavxvnniint8 -mavxneconvert -mcmpccxadd -mamx-fp16 -mprefetchi -mraoint -mamx-complex -mavxvnniint16 -msm3 -msha512 -msm4 -mavx10.2 -mamx-avx512 -mamx-tf32 -mamx-fp8 -mmovrs -mamx-movrs -g -dA gcc/testsuite/gcc.target/i386/sse-13.c -fno-eliminate-unused-debug-{symbols,types} -o sse-13.s
grep -A1 DW_TAG_variable sse-13.s | grep DW_AT_name | grep -v 'scii "__' | grep -v 'DW_AT_name: "__'
shows variables not prefixed with __ and the following patch fixes it.

2025-12-17  Jakub Jelinek  <jakub@redhat.com>

	PR target/123155
	* config/i386/xmmintrin.h (_mm_maskmove_si64): Rename offset automatic
	variable to __offset.

(cherry picked from commit 1e61efc85a78350a287ed8319d81040177813bb6)
---
 gcc/config/i386/xmmintrin.h | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/gcc/config/i386/xmmintrin.h b/gcc/config/i386/xmmintrin.h
index 16f407daaf6f..699420447cc1 100644
--- a/gcc/config/i386/xmmintrin.h
+++ b/gcc/config/i386/xmmintrin.h
@@ -1223,17 +1223,17 @@ _mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)
   __v2di __N128 = __extension__ (__v2di) { ((__v1di) __N)[0], 0 };
 
   /* Check the alignment of __P.  */
-  __SIZE_TYPE__ offset = ((__SIZE_TYPE__) __P) & 0xf;
-  if (offset)
+  __SIZE_TYPE__ __offset = ((__SIZE_TYPE__) __P) & 0xf;
+  if (__offset)
     {
       /* If the misalignment of __P > 8, subtract __P by 8 bytes.
 	 Otherwise, subtract __P by the misalignment.  */
-      if (offset > 8)
-	offset = 8;
-      __P = (char *) (((__SIZE_TYPE__) __P) - offset);
+      if (__offset > 8)
+	__offset = 8;
+      __P = (char *) (((__SIZE_TYPE__) __P) - __offset);
 
       /* Shift __A128 and __N128 to the left by the adjustment.  */
-      switch (offset)
+      switch (__offset)
 	{
 	case 1:
 	  __A128 = __builtin_ia32_pslldqi128 (__A128, 8);
-- 
2.43.7


