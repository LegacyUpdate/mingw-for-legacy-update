From ba342ffc3b2050bf9be778a4b75eab18dec1fb50 Mon Sep 17 00:00:00 2001
From: Lewis Hyatt <lhyatt@gmail.com>
Date: Sat, 15 Nov 2025 23:10:52 -0500
Subject: [PATCH] diagnostics: Fix -fdump-internal-locations for 64-bit
 location_t

When adding support for 64-bit location_t in GCC 15, I missed a couple
changes needed for the internal debugging tool -fdump-internal-locations to
work properly. This would previously ICE on a location_t large enough to
overflow a signed 32-bit int.

gcc/ChangeLog:

	* diagnostic.cc (num_digits): Change argument type from `int' to
	`uint64_t'.
	(test_num_digits): Add test for 64-bit argument.
	* diagnostic.h (num_digits): Adjust prototype.
	* input.cc (write_digit): Accept argument in range 0-9 instead of
	an arbitrary int.
	(write_digit_row): Adjust to change in write_digit().

gcc/testsuite/ChangeLog:

	* gcc.dg/plugin/location-overflow-test-3.c: New test.
	* gcc.dg/plugin/plugin.exp: Add the new test.
---
 gcc/diagnostic.cc                                      |  4 ++--
 gcc/diagnostic.h                                       |  2 +-
 gcc/input.cc                                           |  4 ++--
 gcc/testsuite/gcc.dg/plugin/location-overflow-test-3.c | 10 ++++++++++
 gcc/testsuite/gcc.dg/plugin/plugin.exp                 |  1 +
 5 files changed, 16 insertions(+), 5 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/plugin/location-overflow-test-3.c

diff --git a/gcc/diagnostic.cc b/gcc/diagnostic.cc
index 07c76b6c6526..f2e7f5b85a3a 100644
--- a/gcc/diagnostic.cc
+++ b/gcc/diagnostic.cc
@@ -1566,11 +1566,10 @@ diagnostic_context::report_verbatim (text_info &text)
 /* Get the number of digits in the decimal representation of VALUE.  */
 
 int
-num_digits (int value)
+num_digits (uint64_t value)
 {
   /* Perhaps simpler to use log10 for this, but doing it this way avoids
      using floating point.  */
-  gcc_assert (value >= 0);
 
   if (value == 0)
     return 1;
@@ -2397,6 +2396,7 @@ test_num_digits ()
   ASSERT_EQ (7, num_digits (9999999));
   ASSERT_EQ (8, num_digits (10000000));
   ASSERT_EQ (8, num_digits (99999999));
+  ASSERT_EQ (20, num_digits (uint64_t (-1)));
 }
 
 /* Run all of the selftests within this file.  */
diff --git a/gcc/diagnostic.h b/gcc/diagnostic.h
index 62bffd2c6851..8f4d25528f7c 100644
--- a/gcc/diagnostic.h
+++ b/gcc/diagnostic.h
@@ -1254,7 +1254,7 @@ extern const char *diagnostic_get_color_for_kind (diagnostic_t kind);
 extern char *build_message_string (const char *, ...) ATTRIBUTE_PRINTF_1;
 
 /* Compute the number of digits in the decimal representation of an integer.  */
-extern int num_digits (int);
+extern int num_digits (uint64_t);
 
 inline bool
 warning_enabled_at (location_t loc, diagnostic_option_id option_id)
diff --git a/gcc/input.cc b/gcc/input.cc
index fabfbfb6eaae..085ef1c8f1d7 100644
--- a/gcc/input.cc
+++ b/gcc/input.cc
@@ -1379,7 +1379,7 @@ get_end_location (class line_maps *set, line_map_uint_t idx)
 static void
 write_digit (FILE *stream, int digit)
 {
-  fputc ('0' + (digit % 10), stream);
+  fputc ('0' + digit, stream);
 }
 
 /* Helper function for dump_location_info.
@@ -1396,7 +1396,7 @@ write_digit_row (FILE *stream, int indent,
   for (int column = 1; column < max_col; column++)
     {
       location_t column_loc = loc + (location_t (column) << map->m_range_bits);
-      write_digit (stream, column_loc / divisor);
+      write_digit (stream, (column_loc / divisor) % 10);
     }
   fprintf (stream, "\n");
 }
diff --git a/gcc/testsuite/gcc.dg/plugin/location-overflow-test-3.c b/gcc/testsuite/gcc.dg/plugin/location-overflow-test-3.c
new file mode 100644
index 000000000000..2acf1c3a1c8d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/plugin/location-overflow-test-3.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-fplugin-arg-location_overflow_plugin-value=1024 -fdump-internal-locations" } */
+
+/* The plugin arranges for location_t values to exceed 32 bits; verify the
+   internal dump routines don't crash. The exact output depends on the system
+   and on absolute path names, and this output is only meant for internal
+   purposes, so don't demand an exact form of the output.  */
+
+/* { dg-allow-blank-lines-in-output 1 } */
+/* { dg-prune-output ".*" } */
diff --git a/gcc/testsuite/gcc.dg/plugin/plugin.exp b/gcc/testsuite/gcc.dg/plugin/plugin.exp
index 96e76d2e0c36..4221ae1a63fb 100644
--- a/gcc/testsuite/gcc.dg/plugin/plugin.exp
+++ b/gcc/testsuite/gcc.dg/plugin/plugin.exp
@@ -138,6 +138,7 @@ set plugin_test_list [list \
     { location_overflow_plugin.cc \
 	  location-overflow-test-1.c \
 	  location-overflow-test-2.c \
+	  location-overflow-test-3.c \
 	  location-overflow-test-pr83173.c \
 	  location-overflow-test-pr116047.c \
 	  location-overflow-test-pr120061.c } \
-- 
2.43.7


